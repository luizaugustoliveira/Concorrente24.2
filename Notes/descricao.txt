Processamento de imagens para tentar reduzir o ruido de uma imagem que vai ser passada, o código basicamente tem duas funções e o main e uma função aplica o efeito de reduzir ruidos e a outra calcula que cor aplicar no ruido. A função que voce vai mexer é a que aplica o efeito no ruido e não a que calcula. Fique atento que as threads tem que ser aplicadas sobre a mesma imagem, logo não pode apenas criar uma thread, precisa dividir a imagem de algum jeito e aplica uma thread a cada divisão. Considere que existe uma imagem no diretório. quando falo separar quadrantes é dividir os pixels da imagem e passar um setor para cada thread trabalhar. depois junte cada o que cada thread produziu numa imagem só. use java e considere ; implemente em serial e depois faça uma nova versão de como torna-lo concorrente


### Explicação das Modificações:

1. **Criação das Threads Manualmente**:
    - **Criação de Threads**: Para cada quadrante da imagem, criamos uma nova thread usando `new Thread()`. Dentro de cada thread, chamamos a função `processarQuadrante()` para processar uma parte específica da imagem.
    
    ```java
    threads[(y / (altura / 2)) * 2 + (x / (largura / 2))] = new Thread(() -> {
        processarQuadrante(imagem, startX, startY, largura / 2, altura / 2);
    });
    
    ```
    
    - **Cada thread** recebe como parâmetro a posição e o tamanho do quadrante a ser processado.
2. **Divisão da Imagem em Quadrantes**:
    - A imagem é dividida em 4 quadrantes, e cada quadrante é processado por uma thread separada.
    - Usamos o loop para dividir a imagem em 4 partes, alterando as variáveis `x` e `y` para os limites de cada quadrante:
    
    ```java
    for (int y = 0; y < altura; y += altura / 2) {
        for (int x = 0; x < largura; x += largura / 2) {
            final int startX = x;
            final int startY = y;
            // thread criada para o quadrante
        }
    }
    
    ```
    
3. **Iniciar as Threads**:
    - As threads são **iniciadas com `thread.start()`**.
    
    ```java
    for (Thread thread : threads) {
        thread.start();
    }
    
    ```
    
4. **Aguardar a Conclusão das Threads**:
    - Usamos **`thread.join()`** para garantir que o processo de redução de ruído seja finalizado antes de salvar a imagem. O `join()` bloqueia a execução até que a thread tenha terminado sua execução.
    
    ```java
    for (Thread thread : threads) {
        thread.join();
    }
    
    ```
    

### Resumo das Modificações

- **Criação de Threads Manualmente**: Cada quadrante da imagem é processado em uma thread separada.
- *Divisão da Imagem**: A imagem é dividida em 4 quadrantes, e cada quadrante é atribuído a uma thread.
- **Concorrência**: A aplicação passa a ser concorrente, processando múltiplos quadrantes simultaneamente, o que pode melhorar o desempenho em imagens grandes.

Esse código é um exemplo de como manualmente implementar concorrência em Java utilizando **Threads explícitas** sem usar ferramentas como `ExecutorService`. Isso permite um maior controle sobre o processamento, mas também pode exigir mais cuidado no gerenciamento das threads, como garantir que todas as threads terminem corretamente antes de salvar a imagem.