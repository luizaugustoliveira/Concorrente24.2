Aqui est√° uma explica√ß√£o detalhada de cada parte do c√≥digo:

### **Importa√ß√£o de Pacotes**
```java
import java.util.concurrent.*;
import java.util.Random;
```
- `java.util.concurrent.*`: Importa as classes do pacote `java.util.concurrent`, incluindo `BlockingQueue`, `ArrayBlockingQueue`, `PriorityBlockingQueue`, `TimeUnit`, etc.
- `java.util.Random`: Importa a classe `Random` para gerar n√∫meros aleat√≥rios.

---

## **Etapa 1 e 2: Implementa√ß√£o com `ArrayBlockingQueue`**
### **Classe `Produtor`**
```java
class Produtor implements Runnable {
    private BlockingQueue<Integer> fila;
    private int tempo;
    private Random random = new Random();
```
- `fila`: Fila compartilhada entre o produtor e o consumidor.
- `tempo`: Tempo necess√°rio para produzir um n√∫mero.
- `random`: Objeto para gerar n√∫meros aleat√≥rios.

#### **Construtor**
```java
public Produtor(BlockingQueue<Integer> fila, int tempo) {
    this.fila = fila;
    this.tempo = tempo;
}
```
- Inicializa a fila e o tempo de produ√ß√£o.

#### **M√©todo `run()`**
```java
@Override
public void run() {
    for (int i = 0; i < 10000; i++) { // Gera 10.000 n√∫meros (Etapa 2)
        try {
            int numero = random.nextInt(10) + 1;  // Gera um n√∫mero aleat√≥rio entre 1 e 10
            fila.put(numero); // Insere na fila bloqueante
            System.out.println("Produtor gerou: " + numero);
            Thread.sleep(tempo); // Simula o tempo de produ√ß√£o
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```
- Gera 10.000 n√∫meros aleat√≥rios.
- Usa `fila.put(numero)`, que pode bloquear se a fila estiver cheia.
- Faz uma pausa (`Thread.sleep(tempo)`) para simular o tempo de produ√ß√£o.

---

### **Classe `Consumidor`**
```java
class Consumidor implements Runnable {
    private BlockingQueue<Integer> fila;
    private int tempo;
```
- `fila`: Refer√™ncia √† fila compartilhada.
- `tempo`: Tempo necess√°rio para processar um n√∫mero.

#### **Construtor**
```java
public Consumidor(BlockingQueue<Integer> fila, int tempo) {
    this.fila = fila;
    this.tempo = tempo;
}
```
- Inicializa os atributos `fila` e `tempo`.

#### **M√©todo `run()`**
```java
@Override
public void run() {
    try {
        while (true) {
            Integer numero = fila.poll(600, TimeUnit.MILLISECONDS); // Timeout de 600ms (Etapa 2)
            if (numero == null) {
                System.out.println("Consumidor parou: tempo limite atingido.");
                break;
            }
            System.out.println("Consumidor processou: " + numero);
            Thread.sleep(tempo);
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
```
- `fila.poll(600, TimeUnit.MILLISECONDS)`: Aguarda at√© 600ms por um n√∫mero na fila. Se n√£o houver, retorna `null`, e o consumidor para.
- `Thread.sleep(tempo)`: Simula o tempo de processamento.

---

### **Classe `MainEtapa2`**
```java
public class MainEtapa2 {
    public static void main(String[] args) {
        BlockingQueue<Integer> fila = new ArrayBlockingQueue<>(10); // Fila com capacidade fixa de 10 elementos
        Thread produtor = new Thread(new Produtor(fila, 500)); // Produz a cada 500ms
        Thread consumidor = new Thread(new Consumidor(fila, 700)); // Consome a cada 700ms
        
        produtor.start();
        consumidor.start();
    }
}
```
- Usa `ArrayBlockingQueue` de capacidade 10.
- Inicia um `Produtor` e um `Consumidor` com tempos espec√≠ficos.

---

## **Etapa 3: Implementa√ß√£o com `PriorityBlockingQueue`**
Aqui, a diferen√ßa principal √© o uso de `PriorityBlockingQueue` para que os n√∫meros sejam processados na ordem de prioridade.

### **Classe `ProdutorPrioritario`**
```java
class ProdutorPrioritario implements Runnable {
    private BlockingQueue<Integer> fila;
    private int tempo;
    private Random random = new Random();
```
- Mesma l√≥gica do `Produtor`, mas agora insere os n√∫meros em uma `PriorityBlockingQueue`.

#### **M√©todo `run()`**
```java
@Override
public void run() {
    for (int i = 0; i < 10000; i++) {
        try {
            int numero = random.nextInt(10) + 1;
            fila.put(numero);
            System.out.println("Produtor gerou: " + numero);
            Thread.sleep(tempo);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```
- Insere n√∫meros na fila, mas agora com prioridade (menores valores t√™m prioridade).

---

### **Classe `ConsumidorPrioritario`**
```java
class ConsumidorPrioritario implements Runnable {
    private BlockingQueue<Integer> fila;
    private int tempo;
```
- Igual ao `Consumidor`, mas agora processa elementos de uma `PriorityBlockingQueue`.

#### **M√©todo `run()`**
```java
@Override
public void run() {
    try {
        while (true) {
            Integer numero = fila.poll(600, TimeUnit.MILLISECONDS);
            if (numero == null) {
                System.out.println("Consumidor parou: tempo limite atingido.");
                break;
            }
            System.out.println("Consumidor processou: " + numero);
            Thread.sleep(tempo);
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
```
- Os elementos s√£o retirados da fila seguindo a ordem de prioridade.

---

### **Classe `MainEtapa3`**
```java
public class MainEtapa3 {
    public static void main(String[] args) {
        BlockingQueue<Integer> fila = new PriorityBlockingQueue<>(); // Usando fila de prioridade (Etapa 3)
        Thread produtor = new Thread(new ProdutorPrioritario(fila, 500));
        Thread consumidor = new Thread(new ConsumidorPrioritario(fila, 700));
        
        produtor.start();
        consumidor.start();
    }
}
```
- Substitui `ArrayBlockingQueue` por `PriorityBlockingQueue`.
- Os n√∫meros s√£o consumidos na ordem de prioridade, e n√£o na ordem de inser√ß√£o.

---

## **Resumo das Diferen√ßas**
| Etapa | Tipo de Fila | Caracter√≠stica |
|-------|------------|--------------|
| 1 | `ArrayBlockingQueue` | Produtor e consumidor rodam sem parar. |
| 2 | `ArrayBlockingQueue` | Consumidor tem timeout de 600ms. |
| 3 | `PriorityBlockingQueue` | Consumidor processa n√∫meros em ordem de prioridade. |

Se precisar de mais explica√ß√µes ou ajustes, me avise! üöÄ
